classdef Algorithms<handle
    
    properties
        Data;%Get the data class
        Method;%Get the method class
        
        PevT;PbuyT;PbatT;%Decision variables
        LambdaT; %Dual variables
    end
    
    methods
        function obj = Algorithms(data,method)
            switch data
                case '1'
                    obj.Data=getData1ev1house();
                case '2'
                    obj.Data=getData2ev2house();
                case '100'
                    obj.Data=getData100ev100house();
            end
            switch method
                case 'New'
                    obj.Method=chooseNewmethod();
                    obj.LambdaT=zeros(obj.Data.Nr+obj.Data.Ne,obj.Data.T);
                case 'Prox'
                    obj.Method=chooseProxADMM();
                    obj.LambdaT=zeros(1,obj.Data.T);
                case 'Corr'
                    obj.Method=chooseCorrADMM();
                    obj.LambdaT=zeros(1,obj.Data.T);
            end
            obj.PevT=zeros(obj.Data.Ne,obj.Data.T);
            obj.PbuyT=zeros(obj.Data.Nr,obj.Data.T);
            obj.PbatT=zeros(obj.Data.Nr,obj.Data.T);
        end
        
        function Solve_ALL(obj)
            for k=1:obj.Data.T
                obj.Data.BPVL.UpdateGG2Bat(k);
                GG2BatV=obj.Data.BPVL.GG2Bat(:,k);
                SOCV=obj.Data.BPVL.SOC(:,k);
                SOCV_of_EV=obj.Data.BPVL.SOC_of_EV(:,k);
                [Pev,Pbuy,Pbat,Lambda]=obj.Method.Solve(obj.Data,GG2BatV,SOCV,SOCV_of_EV,k);
                obj.Data.BPVL.UpdateSOC(Pbat,k);
                obj.Data.BPVL.UpdateSOC_of_EV(Pev,k)
                
                obj.PevT(:,k)=Pev;
                obj.PbuyT(:,k)=Pbuy;
                obj.PbatT(:,k)=Pbat;
                obj.LambdaT(:,k)=Lambda;
                
                %Shadow price and SOC
                disp(['price is: ', num2str(-Lambda(1)), '  bat SOC is: ', num2str(obj.Data.BPVL.SOC(1,k))]);
            end
        end
        
        function [Originale,Consistente,f]=Solve_All_convergence(obj,new_s)
            GG2Batv=obj.Data.BPVL.GG2Bat(:,1);
            SOCv=obj.Data.BPVL.SOC(:,1);
            SOCV_of_EV=obj.Data.BPVL.SOC_of_EV(:,1);
            [Originale,Consistente,f]=obj.Method.Solve_convergence(obj.Data,GG2Batv,SOCv,SOCV_of_EV,1,new_s);
        end
        
        
%         function draw(obj)
%             A=zeros(obj.Data.number_of_feeder,48);
%             for i=1:obj.Data.number_of_feeder
%                 for k=1:48
%                     A(i,k)=A(i,k)+obj.Data.minREP.U_feeder(i,:)*[obj.PevT(:,k);obj.PbuyT(:,k)];
%                 end
%             end
%             
%             figure;
%             time=(1:48)/2;
%             
%             legend_str = cell(obj.Data.number_of_feeder, 1);  % 创建图例字符串的单元格数组 
%             
%             hold on; 
%             for i=1:obj.Data.number_of_feeder
%                 plot(time,A(i,:),'LineWidth',1.5)
%                 legend_str{i} = ['\beta=', num2str(obj.Data.minREP.B_feeder(i))];            
%             end
%             hold off;
%             legend(legend_str, 'Location', 'best');  % 添加图例 
%             xlabel('time(h)');ylabel('power(kW)') 
%             title('Real-time loads on different feeders')
%             box on
%         end
        function drawSOC(obj,k1,k2)
            figure;
            time=(0:48)/2;
            hold on;
            plot(time,obj.Data.BPVL.SOC(k1,:))
            plot(time,obj.Data.BPVL.SOC_of_EV(k2,:))
            hold off;
            legend('SOC of Bat','SOC of EV')
        end
        function draw2(obj)
            time=(1:48)/2;
            figure;
            hold on;
            plot(time,sum(obj.Data.BPVL.GG),'g-','LineWidth',1.5)
            plot(time,sum(obj.Data.BPVL.GC),'k--','LineWidth',1.5)
            plot(time,obj.Data.BPVL.GG(1,:),'ro')
            plot(time,obj.Data.BPVL.GC(1,:),'r+')
            plot(time,obj.Data.BPVL.GG(2,:),'bo')
            plot(time,obj.Data.BPVL.GC(2,:),'b+')
            hold off;
            xlabel('time(h)');ylabel('power(kW)')
            legend('PV all','Load all','PV1','Load1','PV2','Load2')
            title('Total power generated by PV and total consumption by users')
        end
        function draw3(obj)
            time=(1:48)/2;
            figure;
            % Resident
            hold on;
            plot(time,obj.Data.BPVL.GC(1,:),'og')% demand
            plot(time,obj.PbuyT(1,:)+obj.Data.BPVL.GG2user(1,:)+obj.PbatT(1,:),'g')
            grid on
            hold off
            xlabel('time(h)');ylabel('power(kW)')
            legend('demand','supply')
            title('The power demanded by user 1 and the power provided to user 1 by the algorithm')
        end
    end
    
end
